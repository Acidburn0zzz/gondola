/*
 * Copyright 2015, Yahoo Inc.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 */

package com.yahoo.gondola.core;

import com.yahoo.gondola.Clock;
import com.yahoo.gondola.Config;
import com.yahoo.gondola.Gondola;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A smarter error logger for exceptions generated by background threads.
 * The logger helps to minimize the noise in the error logs by condensing continuous errors.
 */
public class ExceptionLogger {
    final static Logger logger = LoggerFactory.getLogger(ExceptionLogger.class);

    private final Clock clock;
    private String lastErrorMsg;
    private int suppressedErrors;
    private long displayErrorTs;
    private Function<String, String> messageFn;
    private Class[] noStackTraceClasses;
    private Pattern noStackTracePattern;
    private Function<String, String> additionalMessageFn;

    // Config variables
    private static boolean stackTraceSuppression;

    public ExceptionLogger(Gondola gondola) {
        this.clock = gondola.getClock();
    }

    /**
     * Must be called before logger objects are created.
     */
    public static void initConfig(Config config) {
        config.registerForUpdates(config1 -> {
                    stackTraceSuppression = config1.getBoolean("gondola.stack_trace_suppression");
                }
        );
    }

    public ExceptionLogger setMessage(Function<String, String> messageFunction) {
        this.messageFn = messageFunction;
        return this;
    }

    /**
     * If the exception's message matches the pattern, suppress the stack trace.
     */
    public ExceptionLogger setNoStackTracePattern(String pattern) {
        this.noStackTracePattern = Pattern.compile(pattern);
        return this;
    }

    /**
     * If the exception's class is one of the supplied classes, suppress the stack trace.
     */
    public ExceptionLogger setNoStackTraceClasses(Class... classes) {
        this.noStackTraceClasses = classes;
        return this;
    }

    public ExceptionLogger setAdditionalMessage(Function<String, String> additionalMessageFunction) {
        this.additionalMessageFn = additionalMessageFunction;
        return this;
    }

    private enum Level {
        ERROR,
        WARN,
        INFO
    }

    public void error(Throwable e) {
        log(Level.ERROR, e);
    }

    public void warn(Throwable e) {
        log(Level.WARN, e);
    }

    public void info(Throwable e) {
        log(Level.INFO, e);
    }

    private void log(Level level, Throwable e) {
        long now = clock.now();
        String eMsg = e.getMessage() == null ? "null" : e.getMessage();

        // Make sure the error is printed at least once a minute
        if (!stackTraceSuppression || now > displayErrorTs) {
            lastErrorMsg = null;
            displayErrorTs = now + 60000;
        }

        if (eMsg.equals(lastErrorMsg)) {
            // Skip printing
            suppressedErrors++;
        } else {
            // Possibly suppress the stack trace depending on the exception message
            if (stackTraceSuppression && noStackTracePattern != null) {
                Matcher matcher = noStackTracePattern.matcher(eMsg);
                if (matcher.matches()) {
                    e = null;
                }
            }

            // Possibly suppress the stack trace depending on the class
            if (e != null && stackTraceSuppression && noStackTraceClasses != null) {
                for (Class c : noStackTraceClasses) {
                    if (e.getClass() == c) {
                        e = null;
                        break;
                    }
                }
            }

            // Add number of occurrences
            String msg = messageFn == null ? eMsg : messageFn.apply(eMsg);
            if (suppressedErrors > 1) {
                msg += " (This exception has occurred " + suppressedErrors + " times)";
            }

            // Log it
            switch (level) {
            case ERROR:
                logger.error(msg, e);
                break;
            case WARN:
                logger.warn(msg, e);
                break;
            case INFO:
                logger.info(msg, e);
                break;
            }

            // Print additional message
            String aMsg = additionalMessageFn == null ? null : additionalMessageFn.apply(eMsg);
            logger.info(aMsg);

            suppressedErrors = 0;
            lastErrorMsg = eMsg;
        }
    }
}
